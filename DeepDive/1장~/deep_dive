1장~3장은 소개 및 초기 설정 부분이라 생략

4장 
변수란?
하나의 값을 저장하기 위해 확보한 메모리 공간자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름
즉, 값의 위치를 가르키는 상징적인 이름 또는 식별자 
값의 할당 , 값의 재할당 (상수/변수)

5장
표현식과 문
리터럴(이해할 수 있는 문자, 약속된 기호를 사용해 값을 생성하는 표기법)
리터럴 : 위처럼 기호 문자 표기의 방법
값 : 표현식이 평가된 결과
표현식 : 값으로 평가되는 문 / 표현식이 평가되면 새로운 값을 생성 

6장
데이터타입
원시타입/ 객체타입
원시: 문자,숫자,불리언,undefined,null,심벌
객체:함수,배열,객체
타입추론(변수는 선언이 아닌 할당할때 타입이결정)
동적타이핑(재할당에 의해 변수의 타입은 언제든지 동적으로 변할 수 있다)
type of : 연산자뒤에 나오는 피연산자의 데이터 타입을 문자열로 반환
(const foo = true type of(foo) // boolean)

7장
연산자
산술, 할당, 비교, 논리, 타입, 지수
산술(이항:기본적인거 단항:++ --) => 암묵적타입변환과 타입강제변환이 있다
할당(= += -=)
비교(== === !==)
논리(|| && !) 
삼항 (? t:f)
type of(피연산자의 데이터 타입을 문자열로 반환)

8장 (12/30 읽기시작)
제어문
조건문 / 반복문
조건문: if...else(t/f) / swhich (case=상황별로나눌수있다)
반복문: for/ while / do...while 
*for (let i=0; i<n; i++){
    조건식이 참일경우 반복 실행될 문 
}

9장 타입변환과 단축평가
명시적타입변환 : 개발자가 의도적으로 값의 타입을 변환 (.toString)
암묵적타입변환 : 개발자의 의도와는 상관없이 자바스크립트 엔진의 의해 값의 타입을 변환('10' + 2 ='102')
 if() 사용하면 T/F 로 나온다 

 10장 객체 리터럴 (1/2)
객체리터럴: 객체를 생성하기 위한 표기법
프로퍼티 : 프로퍼티 키와 프로퍼티 값으로 구성 됨
프로퍼티 값이 함수 일 경우 : 메서드 라고 부름
프로퍼티 접근법 : . 또는 []
프로퍼티는 갱신(수정), 생성(추가), 삭제가 가능

11장 원시 값과 객체의 비교 
원시값: 변경 불가능한 값
유사배열객체: 마치 배열처럼 인덱스로 프로퍼티 값에 접근할 수 있고 length(길이) 프로퍼티를 갖는 객체
값의 전달: 값에 의한 전달은 되어도 메모리의 주소값이 변하는 건 아니다 
객체 : 변경 가능한 값
깊은복사, 얕은복사

12장 함수란? => 1/4일 부터
인풋과 아웃풋
자바스크립트의 함수는 객체타입이다 

자바스크립트엔진은 생성된 함수를 호출하기 위해 함수 이름과 동일한 이름의 식별자를 암묵적으로 
생성하고 거기에 객체를 할당한다 (function foo() // console.log(foo) ,foo() // foo => 이값이 나옴) 

- 함수 선언문 : function add(x,y)
- 함수 표현식 : const add  = function(x,y)
- 함수 표현식은 함수호출이 함수표현식보다 먼저 쓰이게 된다면 값을 호출할 수 없다(정의한 생성시점이 다르기에)
  반대로
  함수 선언문은 함수호출이 함수선언문보다 먼저 쓰이게 되어도 값을 호출할 수 있다(함수 호이스팅이라고 한다) 
- function 생성자함수 : function 생성자 함수로 함수를 생성하는 방식은 일반적이지도 않으며 바람직하지 않다
const add = new Function('x,y','return x+y')
- 화살표 함수 : 항상 익명함수.
 const add = (x,y) => x+y
- argumenst : 모든 인수는 암묵적으로 여기에 보관됨 //출력 : argumenst(인수 갯수)
- 매개변수 : 매개변수는 적을 수록 좋다 많을 수록 그만큼 함수가 여러가지 일을 한다는 의미, 최대 3개 적당
- 반환값(return) : 실행결과를 함수 외부로 반환, 반환문은 실행을 중지하고 함수 몸체를 빠져나간다 따라서
  리턴값 이외의 다른문이 있어도 무시된다
- 즉시실행함수(function (){}()) : 단 한번만 호출되며 다시 호출이 없다 ,익명함수를 사용하는 것이 일반적
- 재귀함수 : 자기 자신을 호출하는 함수 => factorial (재귀함수의 함수명) , 탈출 조건을 반드시 만들어야 한다
- 순수함수 : 어떤 외부 상태에도 의존하지 않으며 외부상태를 번경하지 않는 함수, 인수 불변성
- 비순수 함수 : 외부상태에 의존하거나 외부상태를 변경하는 함수, 외부상태에 따라 반환값이 달라짐

13장 스코프란!
유효범위(전역, 지역) 즉 ,식별자(변수명, 함수명 등등) 가 유효한 범위
지역 : 함수 몸체 내부
전역 : 어디든지
스코프 체인 : 모든스코프는 하나의 계층적 구조이며, 최상위는 스포프는 전역스코프,
          이처럼 계층적으로 연결된 것을 스코프 체인이라고 함
함수레벨스코프 : 전역변수가 있고 변수 내 몸체에서 새로운 변수를 선언해 중복선언이 되면 , 값이 재할당됨

14장 전역변수의 문제점 (1/5)
전역 변수 : 생명 주기가가 길다. 즉, 메모리 리소스도 오랜 기간 소비, 검색속도 또한 느리다 
모든 코드를 즉시실행함수로 감싸면모든 변수는 지역변수가 됨

15장 let,const 키워드와 블록 레벨 스코프
둘다 블록 레벨 스코프를 가진다 (지역변수처럼 취급?)
let : 변수 ,키워드 이름 중복 선언 금지
const : 상수, 반드시 선언과 동시에 초기화해야 한다. 재할당 금지!

16장 프로퍼티 어트리뷰트
프로퍼티 상태란? 
프로퍼티의 값, 값의 갱신 여부 ,열거가능여부 , 재정의 가능여부 를 말한다
예)
const person ={
  name:"lee"
}
console.log(Object.getOwnPropertyDescriptor)
// {value:"lee", writable:true, enumerable:true, configurable:true}
(Object.getOwnPropertyDescriptor)이 메서드는 프로퍼티 어트리뷰트 정보를 제공하는
프로퍼티 디스크립터객체를 반환
접근자 프로퍼티 : __proto__ (getter, setter)
데이터 프로퍼티 : {value:"lee", writable:true, enumerable:true, configurable:true}
             디스크립터 객체의 프로퍼티를 누락하면, undefined,false가 기본값
데이터프로퍼티는 확장이 금지된 객체는 프로퍼티 추가가 금지!
Object.isExtensible : 확장여부를 확인 할 수 있다
Object.PreventExtensible : 확장이 금지된다
delete : 추가는 안되자만 삭제는 가능
Object.defineProperty : 프로퍼티 정의에 의한 프로퍼티 추가도 금지
Object.seal : 객체를 밀봉한다, 밀봉된 객체는 읽기와 쓰기만 가능여부 // 확인방법 : Object.isSeal(변수명)
Object.freeze : 객체를 동결한다, 동결된 객체는 읽기만 가능 // 확인방법 : Object.isFrozon(변수명)

17장 생성자 함수에 의한 객체 생성
장점: 객채 생성 방식은 직관적이고 간편, 구조가 동일한 객체 여러개를 간편하게 생성
단점 : 객체를 여러개 생성해야하는 경우 매번 같은 프로퍼티 기술해야하기에 비효율!
Object 생성자 함수 : new Object 호출하면 빈 객체를 생성하여 반환
Object 외에도 String, Number, Boolean Array ... 
[new] : new 연산자와 함께 호출하면 생성자 함수로 동작 없다면??? 일반함수로 동작
어려운데?

18장 일급객체
-함수는 변수,객체(배열도포함)에 저장할 수 있다
-함수의 매개변수에 전달할 수 있다
-함수의 반환값으로 사용할 수 있다
장점 : 일반 객체와 같이 함수의 매개변수에 전달할 수 있으며 함수의 반환값으로 사용할 수 있다

argumenst프로퍼티(모든 인수는 여기 전달 개 수로 나옴)
함수 호출시 전달된 인수들의 정보를 담고 있는 순회가능한 "유사배열 객체"이며 함수 내부에서 지역변수 처럼 가능 즉, 외부 불가능
개 수를 보여주는데 개수가 매개변수보다 적으면 NaN 일치하면 일지할 개 수 초과하면 무시하고 포함된 개수만 반환
에러가 따로 발생하지 않는다 
[유사배열 객체]: length 프로퍼티를 가진 객체로 for문으로 순회할 수 있는 객체

19장 프로토타입
객체지향 프로그래밍 :객체의 집합으로 프로그램을 표현하려는 프로그래밍 패러다임이다
객체 : 속성을 통해 여러 개의 값을 하나의 다뉘로 구성한 복합적인 자료구조
즉, 객체지향 프로그래밍은 '상태를 나타내는 데이터(프로퍼티)'와 상태 데이터를 조작할 수 있는 '동작(메서드)' 이며
'상태 데이터와 동작을 하나의 논리적인 단위로 묶은 복합적인 자료구조'

프로토타입은 객체 간에 코드 및 속성을 공유하는 방법을 제공한다. 
어떤 객체의 프로토타입을 다른 객체로 지정하면, 후자는 전자의 속성과 메서드를 상속받게 된다.
이를 통해 코드의 재사용성이 증가하고 객체 간에 유사한 동작을 공유할 수 있다.

모든 객체는 프로토타입을 가지고 있고,모든 프로토타입은 생성자 함수와 연결되어있다
__proto__접근자 프로퍼티를 통해 내부슬롯에 간접적으로 접근할 수 있다.
- 프로토타입과 생성자 함수는 단독으로 존재할 수 없고 언제나 쌍으로 존재한다
- 프로토타입은 생성자 함수가 생성되는 시점에 더불어 생성된다.

너무 어려워,,,,

프로토타입체인 : 객체의 프로토타입은 또 다른 객체이며, prototype이라는 특별한 속성을 가지고 있다. 
             이 속성은 해당 객체의 프로토타입을 가리키며, 이를 통해 상속 관계를 구축한다.
             자바스크립트는 객체의 접근할때 해당 객체에 접근하려는 프로퍼티가 없다면 [[prototype]] 내부슬롯의
             참조에 따라 자신의 부모역할을 하는 프로토타입의 프로퍼티를 순차적으로 검색하는 것
섀도잉 : 상속관계에 의해 플퍼티가 가려지는 현상
오버라이딩 : 상위 클래스가 가지고 있는 메서드를 하위 클래스가 재정의하여 사용하는 방식

프로토타입은 생성자함수 또는 인스턴스에 의해 교체할 수 있다

instanceof : 이 연산자는 객체가 특정 클래스 또는 생성자 함수의 인스턴스인지를 확인하는 데 사용한다.
사용법 : [bject instanceof constructor]
여기서 object는 검사하려는 객체이고, constructor는 특정 클래스 또는 생성자 함수이다. 
만약 object가 constructor의 인스턴스이면 true를 반환하고, 그렇지 않으면 false를 반환

Object.create : 이 메서드는 JavaScript에서 사용되는 객체 생성 방법 중 하나이며,(정적메서드이다)
                새로운 객체를 생성하고 지정된 프로토타입 객체를 사용하여 직접 상속하는 데 사용한다.
                객체 간의 상속을 명시적으로 조작하거나, 프로토타입 체인을 조작하여 필요한 상속 구조를 만들 수 있다.
사용법 : [Object.create(proto[, propertiesObject])]
proto: 새로 생성되는 객체의 프로토타입이 될 객체이다.
propertiesObject (선택 사항): 속성 디스크립터를 포함하는 객체로, 새로운 객체에 추가할 속성을 정의한다.

in : 이 연산자는 객체 내에 특정프로퍼티가 존재하는지 여부를 확인한다
사용법 : [propertyName in object]
propertyName: 확인하려는 속성의 이름입니다.
object: 확인 대상이 되는 객체입니다.

for...in 문 : 객체의 속성을 열거하는 데 사용
사용법 : [for (variable in object) {
  // object의 속성에 대한 처리
}]
variable: 각 반복에서 현재 속성의 키가 할당될 변수입니다.
object: 열거할 객체입니다.

아 너무 어려워 이해가 안돼...