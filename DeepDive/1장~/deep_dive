1장~3장은 소개 및 초기 설정 부분이라 생략

4장 
변수란?
하나의 값을 저장하기 위해 확보한 메모리 공간자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름
즉, 값의 위치를 가르키는 상징적인 이름 또는 식별자 
값의 할당 , 값의 재할당 (상수/변수)

5장
표현식과 문
리터럴(이해할 수 있는 문자, 약속된 기호를 사용해 값을 생성하는 표기법)
리터럴 : 위처럼 기호 문자 표기의 방법
값 : 표현식이 평가된 결과
표현식 : 값으로 평가되는 문 / 표현식이 평가되면 새로운 값을 생성 

6장
데이터타입
원시타입/ 객체타입
원시: 문자,숫자,불리언,undefined,null,심벌
객체:함수,배열,객체
타입추론(변수는 선언이 아닌 할당할때 타입이결정)
동적타이핑(재할당에 의해 변수의 타입은 언제든지 동적으로 변할 수 있다)
type of : 연산자뒤에 나오는 피연산자의 데이터 타입을 문자열로 반환
(const foo = true type of(foo) // boolean)

7장
연산자
산술, 할당, 비교, 논리, 타입, 지수
산술(이항:기본적인거 단항:++ --) => 암묵적타입변환과 타입강제변환이 있다
할당(= += -=)
비교(== === !==)
논리(|| && !) 
삼항 (? t:f)
type of(피연산자의 데이터 타입을 문자열로 반환)

8장 (12/30 읽기시작)
제어문
조건문 / 반복문
조건문: if...else(t/f) / swhich (case=상황별로나눌수있다)
반복문: for/ while / do...while 
*for (let i=0; i<n; i++){
    조건식이 참일경우 반복 실행될 문 
}

9장 타입변환과 단축평가
명시적타입변환 : 개발자가 의도적으로 값의 타입을 변환 (.toString)
암묵적타입변환 : 개발자의 의도와는 상관없이 자바스크립트 엔진의 의해 값의 타입을 변환('10' + 2 ='102')
 if() 사용하면 T/F 로 나온다 

 10장 객체 리터럴 (1/2)
객체리터럴: 객체를 생성하기 위한 표기법
프로퍼티 : 프로퍼티 키와 프로퍼티 값으로 구성 됨
프로퍼티 값이 함수 일 경우 : 메서드 라고 부름
프로퍼티 접근법 : . 또는 []
프로퍼티는 갱신(수정), 생성(추가), 삭제가 가능

11장 원시 값과 객체의 비교 
원시값: 변경 불가능한 값
유사배열객체: 마치 배열처럼 인덱스로 프로퍼티 값에 접근할 수 있고 length(길이) 프로퍼티를 갖는 객체
값의 전달: 값에 의한 전달은 되어도 메모리의 주소값이 변하는 건 아니다 
객체 : 변경 가능한 값
깊은복사, 얕은복사

12장 함수란? => 1/4일 부터
인풋과 아웃풋
자바스크립트의 함수는 객체타입이다 

자바스크립트엔진은 생성된 함수를 호출하기 위해 함수 이름과 동일한 이름의 식별자를 암묵적으로 
생성하고 거기에 객체를 할당한다 (function foo() // console.log(foo) ,foo() // foo => 이값이 나옴) 

- 함수 선언문 : function add(x,y)
- 함수 표현식 : const add  = function(x,y)
- 함수 표현식은 함수호출이 함수표현식보다 먼저 쓰이게 된다면 값을 호출할 수 없다(정의한 생성시점이 다르기에)
  반대로
  함수 선언문은 함수호출이 함수선언문보다 먼저 쓰이게 되어도 값을 호출할 수 있다(함수 호이스팅이라고 한다) 
- function 생성자함수 : function 생성자 함수로 함수를 생성하는 방식은 일반적이지도 않으며 바람직하지 않다
const add = new Function('x,y','return x+y')
- 화살표 함수 : 항상 익명함수.
 const add = (x,y) => x+y
- argumenst : 모든 인수는 암묵적으로 여기에 보관됨 //출력 : argumenst(인수 갯수)
- 매개변수 : 매개변수는 적을 수록 좋다 많을 수록 그만큼 함수가 여러가지 일을 한다는 의미, 최대 3개 적당
- 반환값(return) : 실행결과를 함수 외부로 반환, 반환문은 실행을 중지하고 함수 몸체를 빠져나간다 따라서
  리턴값 이외의 다른문이 있어도 무시된다
- 즉시실행함수(function (){}()) : 단 한번만 호출되며 다시 호출이 없다 ,익명함수를 사용하는 것이 일반적
- 재귀함수 : 자기 자신을 호출하는 함수 => factorial (재귀함수의 함수명) , 탈출 조건을 반드시 만들어야 한다
- 순수함수 : 어떤 외부 상태에도 의존하지 않으며 외부상태를 번경하지 않는 함수, 인수 불변성
- 비순수 함수 : 외부상태에 의존하거나 외부상태를 변경하는 함수, 외부상태에 따라 반환값이 달라짐

13장 스코프란!
유효범위(전역, 지역) 즉 ,식별자(변수명, 함수명 등등) 가 유효한 범위
지역 : 함수 몸체 내부
전역 : 어디든지
스코프 체인 : 모든스코프는 하나의 계층적 구조이며, 최상위는 스포프는 전역스코프,
          이처럼 계층적으로 연결된 것을 스코프 체인이라고 함
함수레벨스코프 : 전역변수가 있고 변수 내 몸체에서 새로운 변수를 선언해 중복선언이 되면 , 값이 재할당됨

14장 전역변수의 문제점 (1/5)
전역 변수 : 생명 주기가가 길다. 즉, 메모리 리소스도 오랜 기간 소비, 검색속도 또한 느리다 
모든 코드를 즉시실행함수로 감싸면모든 변수는 지역변수가 됨

15장 let,const 키워드와 블록 레벨 스코프
둘다 블록 레벨 스코프를 가진다 (지역변수처럼 취급?)
let : 변수 ,키워드 이름 중복 선언 금지
const : 상수, 반드시 선언과 동시에 초기화해야 한다. 재할당 금지!

16장 프로퍼티 어트리뷰트


